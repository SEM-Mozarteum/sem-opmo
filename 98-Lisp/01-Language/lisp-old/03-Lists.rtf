{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Palatino-Roman;\f2\froman\fcharset0 Times-Roman;
\f3\fmodern\fcharset0 Courier;\f4\fnil\fcharset128 HiraKakuProN-W3;}
{\colortbl;\red255\green255\blue255;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li574\fi13\pardirnatural

\f0\fs48 \cf0 Introduction to Common Lisp\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\li574\fi13\qj

\fs28 \cf0 \'a9
\f1  2016 , Studio for Electronic Music, University Mozarteum Salzburg\
\pard\pardeftab720\fi558

\f2\b\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li574\fi13\pardirnatural

\f0\b0\fs36 \cf0 Lists\
\
\pard\pardeftab720\fi558

\f1\fs24 \cf0 List is the most important data type in Lisp. Lists can be used to represent practically anything:  \
sets, melodies, rhythms, etc.\
Lists consist of items enclosed in parentheses. These items are called the elements of the list. \
Here are some valid lists:\
\
\pard\pardeftab720\fi558

\f3 \cf0 '(60 62 70 56 68 64)
\f1 \
\
IMPORTANT: The list has to be quoted with 
\b '
\b0  (quote) at the beginning not to be evaluated.\
Otherwise the "60" is interpreted as an (unknown) function.\
\

\f3 '((60 62 70) (56 68 64)) ; a list of lists\
\
'((1 (1 1 1)) (2 (1.0 1))) ; nested lists
\f1 \
\
You can create a list with the function list:\
\pard\pardeftab720\fi558

\f2 \cf0 \
\pard\pardeftab720\fi558

\f3 \cf0   (list 'a 'b 'c) 
\f4 \'81\'cb
\f3  (A B C)\
\
\pard\pardeftab720\fi558

\f1 \cf0 Cons requires two arguments. The data type of the first is arbitrary. \
The second has to be a list. Cons adds the values of the first argument \
to the beginning of the list (second argument) and returns the new list.
\f3 \
\
(cons '1 '(2 3)) ; => (1 2 3) \
\
(cons '(1) '(2 3)) ; => ((1) 2 3)\
\
(cons '1 NIL) ; => (1)\
\

\f1 Append is used to concatenate lists. This function requires only lists as inputs. \
The number of lists is arbitrary. The result is one new list.
\f3 \
\
(append '(1) '(2) '(3)) ; => (1 2 3) \
 \

\f1 If one of the lists contains other lists, these lists are preserved.\
\pard\pardeftab720\fi558

\f3 \cf0 \
(append '(1 (2)) '(3)) ; => (1 (2) 3)\
\
\pard\pardeftab720\fi558

\f1 \cf0 Empty lists are ignored.\
\pard\pardeftab720\fi558

\f3 \cf0 \
(append '(1) nil '(2 3)) ; => (1 2 3)\
\
\pard\pardeftab720\fi558

\f1 \cf0 You can access the members of a list with the functions car (or first) and cdr (or rest):\
\pard\pardeftab720\fi558

\f2 \cf0 \
\pard\pardeftab720\fi558

\f3 \cf0   (setf lis '(a b c))\
  (car lis) 
\f4 \'81\'cb
\f3  a\
  (first lis) 
\f4 \'81\'cb
\f3  a\
\
  (cdr lis) 
\f4 \'81\'cb
\f3  (b c)\
  (rest lis) 
\f4 \'81\'cb
\f3  (b c)\
\
\pard\pardeftab720\fi558

\f1 \cf0 Common Lisp also defines the functions second, third and fourth (on up to tenth). \
Note that second is not the same as cdr or rest. cdr and rest both return the remaining \
list after the first element, while second returns the second item in the list:\
\
\pard\pardeftab720\fi558

\f3 \cf0   (rest lis)   
\f4 \'81\'cb
\f3  (b c)\
  (second lis) 
\f4 \'81\'cb
\f3  b\
  (third lis)  
\f4 \'81\'cb
\f3  c\
  (fourth lis) 
\f4 \'81\'cb
\f3  nil\
\
\pard\pardeftab720\fi558

\f1 \cf0 Lists are sequences, so functions that operate on sequences also operate on lists:\
\
\pard\pardeftab720\fi558

\f3 \cf0   (subseq lis 0 1)  
\f4 \'81\'cb
\f3  (a)\
  (subseq lis 0 2)  
\f4 \'81\'cb
\f3  (a b)\
\
\pard\pardeftab720\fi558

\f1 \cf0 The function nth also allows you to retrieve selected items from a list.\
Note that the first item in a list is the 0th. \
\
\pard\pardeftab720\fi558

\f3 \cf0   (nth 0 lis)  
\f4 \'81\'cb
\f3  a\
\
\pard\pardeftab720\fi558

\f1 \cf0 To retrieve the length of a list use the [length] funtion:
\f3 \
\
	  (length '(1 2 3 4 5 6)) ; => 6\
\

\f1 Simply the reversed list:
\f3 \
\
(reverse '(4 2 3 11 5 6 1)) ; => (1 6 5 11 3 2 4)\
\

\f1 With sort a list is sorted with a specified attribute:
\f3 \
\
(sort '(60 64 56 45 66 87) #'<) ; => (45 56 60 64 66 87)\
\
(sort '(60 64 56 45 66 87) #'>) ; => (87 66 64 60 56 45)\
\

\f1 The list is reduced according to a given funcion:
\f3 \
\
(reduce  '+ '(1 2 3 4)) ; => 10\

\f1 In this case it's the same as (+ 1 2 3 4)
\f3 \
\
(reduce '/ '(1 2 3 4)) ; => 1/24\
\
\
\
\
\
}