;;; ---------------------------------------------------------
;;; Opusmodus Tutorial
;;; Studio for Electronic Music (SEM)
;;; University Mozarteum, Salzburg
;;; (c) 2015 - 2017, Achim Bornhoeft
;;; ---------------------------------------------------------

;;; SHORT INTRODUCTION TUTORIAL

;;; ---------------------------------------------------------
;;; Pitches
;;; ---------------------------------------------------------

(gen-repeat 6 'c4) ; => (c4 c4 c4)
(gen-repeat 3 '(c4 d4 fs4)) ; => (c4 d4 fs4 c4 d4 fs4 c4 d4 fs4)
;; reversed version
(reverse (gen-repeat 3 '(c4 d4 fs4))) 

;; set the variable "12-notes" to a chromatic scale
(setf 12-notes '(c4 cs4 d4 ds4 e4 f4 fs4 g4 gs4 a4 as4 b4))

;; reorder notes randomly
(rnd-order 12-notes)

;; Pick random items from a single list, allowing repeats
(setf rnd-notes (rnd-repeat 20 12-notes :seed 1))
;; the seed argument sets and fixes ONE random choice.

;; random of registers in a specific range
(rnd-octave 'cello rnd-notes)	 

;;; ---------------------------------------------------------

;; twelve-tone row
;; in integer notation 0 = 60 = c4 => -2 = 58 = bb3
(setf row '(9 5 4 10 7 2 6 0 1 3 8 11))

;; conversion to pitches
(integer-to-pitch row)

;; transposition
(integer-to-pitch (integer-transpose 5 row))

;; reversed row
(integer-to-pitch (reverse row))

;; inverted row
(integer-to-pitch (row-invert row))

;; reversed invertion
(integer-to-pitch (reverse (row-invert row)))

;;; ---------------------------------------------------------
;;; Chords
;;; ---------------------------------------------------------

;; Converting melodies to chords
(chordize '(c4 f4 d4 )) ; => (c4d4f4)
;; and vice versa
(melodize '(c4d4f4)) ; => (c4 d4 f4)

;; several chords
(chordize-list '((c4 gs3) (g4 d4) (d4 f4 fs4) (eb4 c4 cs4)))

#|
The 'respell' function can be used to change the pitch name of 
chord clusters to avoid the identical note names that produce 
conflicts in notation display. The function will also respell 
ascending pitch sequences to sharps and flats when pitches 
descend.
|#

(respell '(c4cs4)) ; => (c4db4)
(respell '(c4cs4f4fs4)) ; => (c4db4f4gb4)
;; => (c4 cs4 d4 ds4 e4 f4 fs4 g4 gs4 a4 as4 b4)

;;; ---------------------------------------------------------
;;; Durations
;;; ---------------------------------------------------------

;; Derivation of durations from a given pitch list with span

(setf pitches rnd-notes) ; 20 notes
(setf durations (span pitches '(1/16)))

;; Putting together pitches and durations with make-omn

(make-omn 
 :length durations
 :pitch pitches)

(setf durations1 (span pitches '(1/16 1/8 1/16 1/12 1/12 1/12)))
;; span is automatically looping the list

(setf mat1 (make-omn 
            :length durations1
            :pitch pitches))

;;; ---------------------------------------------------------
;;; Plotting
;;; ---------------------------------------------------------

;; to plot the material use omn-list-plot

(omn-list-plot mat1)
(omn-list-plot mat1 :join-points t)
(omn-list-plot mat1 :join-points t :style :fill)

;;; ---------------------------------------------------------
;;; Voices
;;; ---------------------------------------------------------

;; First we create a list of notes:
(setf note-mat (rnd-row :type :pitch))
;; the :pitch keyword makes the output being pitches
;; the :seed number freezes the random choice

;;; 2 musical materials derived from 'note-mat'

;; Material 1
(setf notes-mat1 note-mat)
(setf durs-mat1 (span notes-mat1 '(1/16))) ; 1/16 repetition

(setf mat1 
      (make-omn
       :pitch notes-mat1
       :length durs-mat1))

;; Material 2
(setf notes-mat2 (pitch-transpose -6 (subseq note-mat 0 6)))
;; subsequence from note-mat (first 6 notes)
;; transposed 6 semitones down
(setf durs-mat2 (span notes-mat2 '(1/8))) ; 1/8 repetition

(setf mat2
      (make-omn
       :pitch notes-mat2
       :length durs-mat2))

;;; Concatenating material

;; append the first to the second material (merge in one measure)
(append mat1 mat2 mat1)

;; put the two materials in seperate measures
(setf voice1 (list mat1 mat2 mat1 mat2))
(setf voice2 (list mat2 mat1 mat2 mat1))

;; voices as transpositions of other voices
(setf voice3 (pitch-transpose -6 voice1)) 
(setf voice4 (pitch-transpose -13 voice2))

;;; ---------------------------------------------------------
;;; Parts
;;; ---------------------------------------------------------

;; To merge 2 voices in one part use merge-voices
;; To avoid note collisions use respell
(setf part1 (respell (merge-voices voice1 voice2)))
(setf part2 (respell (merge-voices voice3 voice4)))

;;; ---------------------------------------------------------
;;; Score
;;; ---------------------------------------------------------

(def-score score1 ; name of the score
           ;; general score definition:
           (:key-signature 'chromatic
            :time-signature '(3 4)
            :tempo 60)
           
  (Vibraphone ; name of the system
   :omn part1
   :channel 1
   :sound 'gm ; midi system
   :program 'Vibraphone) ; instrument
  
  (Violoncello
   :omn part2
   :channel 2
   :sound 'gm
   :program 'Cello)
  ) 

;;; ---------------------------------------------------------
;;; Display
;;; ---------------------------------------------------------

;; compile and play the score in the midi player
(display-midi (compile-score 'score1))

;; display the notation
(display-musicxml 'score1)

;;; ---------------------------------------------------------
;;; Dynamics
;;; ---------------------------------------------------------

;; The are 12 dynamic symbols in Opusmodus by default
(get-velocity '(ppppp pppp ppp pp p mp mf f ff fff ffff fffff))
;; These dynamics are distibuted between 0 and 1
;; => (0.02 0.11 0.19 0.27 0.35 0.43 0.5 0.58 0.66 0.74 0.84 1.0)

;; Get the dynamic symbols from velocity values between 0.02 and 1.0
;; with the type keyword symbol
(get-velocity 
 '(0.02 0.11 0.19 0.27 0.35 0.43 0.5 0.58 0.66 0.74 0.84 1.0) :type :symbol)
;; => (ppppp pppp ppp pp p mp mf f ff fff ffff fffff)

;; Make a crescendo from pp to f in 7 steps
(gen-cresc 5 'pp 'f) ; => (pp p p mp mf mf f)

;; Make a diminuendo between fff and p in 20 steps
(gen-dim 20 'fff 'p) ; => fff fff ff ff ff ff f f f f mf mf mf mf mp mp mp p p p)

(gen-dynamic '(3 5 4 4 5) '(pp f ff mf f))
;; => (pp< < < f< < < < < ff> > > > mf< < < < f f f f f)

;; Example with optional end velocity value:

(setf velocities1 (gen-dynamic '(3 5 4 4 5) '(pp f ff mf f) 'p))
;; => (pp< < < f< < < < < ff> > > > mf< < < < f> > > > p)

;; Make pitches according to dynamics
(setf pitches1 (span velocities1 '(c4 fs4 b4)))

;; Make pitches according to dynamics
(setf durations1 (span velocities1 '(1/8)))

(make-omn
 :pitch pitches1
 :length durations1
 :velocity velocities1)

;;; ---------------------------------------------------------
;;; Dynamics
;;; ---------------------------------------------------------

(make-omn
 :pitch pitches1
 :length '(1/8)
 :articulation '(stacc)
 :velocity velocities1
 :span :pitch)






