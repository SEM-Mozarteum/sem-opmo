{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Palatino-Roman;\f2\froman\fcharset0 Times-Roman;
\f3\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;}
\vieww20120\viewh19520\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li574\fi13\pardirnatural

\f0\fs48 \cf0 Introduction to Common Lisp\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\li574\fi13\qj

\fs28 \cf0 \'a9
\f1  2016 , Studio for Electronic Music, University Mozarteum Salzburg\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li574\fi13\pardirnatural

\f2\b\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li574\fi13\pardirnatural

\f0\b0\fs36 \cf0 Bindings\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li574\fi13\pardirnatural

\f2\b \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\li574\fi13

\f1\b0\fs24 \cf0 Binding is the act of specifying a place holder for a value.  \
You often want to do this because it is cumbersome to write \
out long expressions multiple times, or if a computation needs \
to be done in small parts where a binding needs to be updated \
at various times during execution. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\li574\fi13\qj

\b\fs36 \cf0 Global Variables
\b0\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\li574\fi13
\cf0 \
We start by setting a symbol's general purpose value. There are several commands\
for setting the values of symbols, set, setq, setf, psetq, psetf. One can get a long \
way with just setf so we start with that one:\
\

\f3 (setf my-first-symbol 57)\
57
\f1 \
\
This sets the general purpose value of the symbol MY-FIRST-SYMBOL to 57, \
and returns 57. Now we can type\
\

\f3 my-first-symbol\
57
\f1 \
\
and\
\

\f3 (+ my-first-symbol 3)\
60\
\
(setf second-symbol (+ 20 3))\
23
\f1 \
\
Well, plainly this has performed the calculation, and returned the answer, \
but what did the general purpose value of our second-symbol get set to? \
Have we used it to record the calculation we requested, (+ 20 3), \
or the answer that the computer calculated?\
\

\f3 second-symbol\
23
\f1 \
\
If we want to record the calculation for future reference we must "quote" it. \
Think of the computer as a horse and the quote as a bridle, reining it in, \
stopping it from rushing on to evaluate things before you want it to.\
\

\f3 (setf lis (list 1 2 3 4 5))\
(1 2 3 4 5)
\f1 \
\
Now evaluate\
\

\f3 lis\
(1 2 3 4 5)
\f1 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\li574\fi13\qj

\b\fs36 \cf0 Local Variables\

\b0\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\li574\fi13
\cf0 The main way to create local bindings to variables  is via the \'93special form\'94 LET.\
\

\f3 (let ((5-squared (* 5 5))\
      (10-squared (* 10 10)) )\
  (* 5-squared 10-squared))\
\
=> 2500
\f1 \
\
Here, 5-SQUARED and 10-SQUARED are place holders ("local variables") for the \
results of the calculation (* 5 5) and (* 10 10), respectively. It is good to note at this \
time that there are very few rules regarding what can be used as a place holder. \
These place holders are called symbols and it can have a name that includes most \
any characters with the exception of quotes, open or close parenthesis, colons, \
backslashes, or vertical bars (\'91|\'92). These all have special syntactical meaning in \
Common Lisp. It is good to note that all of these things actually can be in the name \
of a symbol but they require special escaping.\
Bindings have a limited scope. Once the LET form closes, the binding is invalidated. \
This means that this is an error, because a is referred to outside of the enclosing LET form.\
\

\f3 (let ((a (sqrt 100))))\
(print a) ; => Error: Unbound variable: a
\f1 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\li574\fi13\qj

\b\fs36 \cf0 Dynamic Bindings
\b0\fs24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\li574\fi13
\cf0 \
The story gets a bit more complex, there are two types of way to make bindings in \
Common Lisp, lexical, which we have just seen, and dynamic. For our purposes at \
this point, dynamic bindings are not much different from lexical bindings, but they \
are made in a different way and do not have the same finite extent of the LET form. \
We can use DEFVAR and DEFPARAMETER to make dynamic bindings. \
These can hold a value in between inputs.\
	\
DEFPARAMETER always assigns a value. So:\
\

\f3 [1]> (defparameter a 1) ; => A\
[2]> (defparameter a 2) ; => A\
[3]> a ; => 2
\f1 \
\
while DEFVAR does it only once, so:\
\

\f3 [4]> (defvar b 1) ; => B\
[5]> (defvar b 2) ; => B\
[6]> b ; => 1}